import json
import meep as mp
import numpy as np 
import matplotlib.pyplot as plt
import SimLibrary as SL

# -----------------------------
# Simulation setup
# -----------------------------
sim_mode_resolution = 40
sim_prop_resolution = 20
sim_time = 200

# Cladding geometry
cld_length = 5
cld_width = 5
cld_height = 0

# Waveguide geometry
wvg_length = cld_length
wvg_height = 0
wvg_width = 1
cld_neff = 1.72
wvg_neff = 3.21

# Source parameters
src_wvl = 1.550
src_freq = 1 / src_wvl

# Boundary conditions
pml_thickness = 1.0

# Geometry definition
geometry = [
        mp.Block(size=mp.Vector3(cld_length, cld_width, cld_height),
                center=mp.Vector3(),
                material=mp.Medium(epsilon=cld_neff**2)),
        mp.Block(size=mp.Vector3(wvg_length, wvg_width, wvg_height),
                center=mp.Vector3(),
                material=mp.Medium(epsilon=wvg_neff**2))]

# -----------------------------
# Simulation Extraction
# -----------------------------
mode_already_solved = True
if not mode_already_solved:
        Ez1_cross, Hy1_cross, neff = SL.finding_mode_from_geometry(geometry, 
                                                                   frequency=src_freq,
                                                                   mode=1,
                                                                   resolution=sim_mode_resolution)

        cross_axis = np.linspace(-cld_width/2, cld_width/2, len(Ez1_cross))

        data = {
        "Ez": Ez1_cross.tolist(),
        "Hy": Hy1_cross.tolist(),
        "neff": float(neff),
        "cross_axis": cross_axis.tolist()
        }

        with open("Output/Mode_ex1.json", "w") as f:
                json.dump(data, f)
else:
        with open("Output/Mode_ex1.json") as f:
                data = json.load(f)

        Ez1_cross = np.array(data["Ez"])
        Hy1_cross = np.array(data["Hy"])
        neff = data["neff"]
        cross_axis = np.array(data["cross_axis"])

# Update the geometry variables
cld_length2 = 50
cld_width2 = 5
wvg_length2 = cld_length2
wvg_shift2 = 0.6

# Linear taper
taper_width = 0.5
taper_length = 20
taper_vertices = [mp.Vector3(-wvg_length2/2-taper_length/2-5, -cld_width/2),
                  mp.Vector3(-wvg_length2/2-taper_length/2-5, -wvg_width/2),
                  mp.Vector3(-wvg_length2/2-taper_length/2, -wvg_width/2),
                  mp.Vector3(wvg_length2/2+taper_length/2, -taper_width/2),
                  mp.Vector3(wvg_length2/2+taper_length/2+5, -taper_width/2),
                  mp.Vector3(wvg_length2/2+taper_length/2+5, +taper_width/2),
                  mp.Vector3(wvg_length2/2+taper_length/2, +taper_width/2),
                  mp.Vector3(-wvg_length2/2-taper_length/2, +wvg_width/2),
                  mp.Vector3(-wvg_length2/2-taper_length/2-5, +wvg_width/2),
                  mp.Vector3(-wvg_length2/2-taper_length/2-5, +cld_width/2),]

matgrid = SL.polygon_to_materialgrid(
        vertices=taper_vertices,
        medium_outside=mp.Medium(epsilon=cld_neff**2),
        medium_inside=mp.Medium(epsilon=wvg_neff**2),
        sub_resolution=sim_prop_resolution*1)

taper = [mp.Block(size=mp.Vector3(cld_length2+taper_length+10, cld_width2, cld_height),
                  center=mp.Vector3(),
                  material=matgrid)]

# Two waveguide separated to simulate a coupler
coupler = [
        mp.Block(size=mp.Vector3(cld_length2, cld_width2, cld_height),
                center=mp.Vector3(),
                material=mp.Medium(epsilon=cld_neff**2)),
        mp.Block(size=mp.Vector3(wvg_length2, wvg_width, wvg_height),
                center=mp.Vector3(0, wvg_shift2),
                material=mp.Medium(epsilon=wvg_neff**2)),
        mp.Block(size=mp.Vector3(wvg_length2, wvg_width, wvg_height),
                center=mp.Vector3(0, -wvg_shift2),
                material=mp.Medium(epsilon=wvg_neff**2))]
# Select the geometry
geometry = taper
cell_size, cell_center = SL.compute_geometry_bounds(geometry)

# Creat a source from the mode fields
source = SL.generate_modal_source(Ez_cross = Ez1_cross,
                                  Hy_cross = Hy1_cross,
                                  cross_axis = np.linspace(-cld_width/2, cld_width/2, len(Ez1_cross)),
                                  src_position = mp.Vector3(-cld_length2 / 2 - taper_length/2 - 5 + pml_thickness, 0),
                                  src_size=mp.Vector3(0, cld_width2),
                                  frequency=src_freq)

pml_layers = [mp.PML(pml_thickness)]
sim = mp.Simulation(
    cell_size=cell_size,
    sources=source,
    geometry=geometry,
    resolution=sim_prop_resolution,
    boundary_layers=pml_layers
)

# Define DFT fields to be recorded
dft = sim.add_dft_fields([mp.Ez, mp.Hy], src_freq, 0, 1, 
                         where=mp.Volume(center=mp.Vector3(),
                                         size=cell_size))

# Run the simulation
sim.run(until=wvg_length2*neff*2)

# Visualize the geometry simulated
eps_data = sim.get_array(center=mp.Vector3(0, 0, 0), 
                         size=cell_size, 
                         component=mp.Dielectric)

# Extract the fields at the DFT region
ez_data = sim.get_dft_array(dft, mp.Ez, 0)
hy_data = sim.get_dft_array(dft, mp.Hy, 0)

plt.figure()
plt.imshow(eps_data.transpose(), interpolation='spline36', cmap='binary', aspect='auto')
plt.imshow(abs(ez_data).transpose(), interpolation='spline36', cmap='RdBu', alpha=0.9, aspect='auto')
plt.axis('off')
plt.show()

# Extract the field axis 
if geometry == coupler:
        cross_axis_used = cross_axis + wvg_shift2   
else:
        cross_axis_used = cross_axis
field_axis = np.linspace(-cld_width2/2, cld_width2/2, len(ez_data[0]))
overlap = SL.calculate_modal_overlap(Ez_cross = Ez1_cross, 
                                     Hy_cross = Hy1_cross, 
                                     Ez_field = ez_data, 
                                     Hy_field = hy_data,
                                     cross_axis = cross_axis_used,
                                     field_axis = field_axis)
plt.plot(overlap)
plt.grid()
plt.show()

# > CALCULATE BEND GEOMETRY
# > VISUALIZE MODE, PROP... in one plot
