from matplotlib.widgets import Button
import matplotlib.pyplot as plt
import SimLibrary as SL
import numpy as np
import meep as mp
import json 

width_found = True
mode_calculated_kind = 'none' # Chose one between 'none', 'wvg', 'fiber'
mode_calculated = (mode_calculated_kind == 'none')
propagation_waveguide = True
propagation_coupler = True
propagation_mmi = True
propagation_taper = True
propagation_curve = False

#################################################################
###  1 - Find waveguide width for single mode in wanted range ###
#################################################################
# If we need to determine the mode in the wavelength of interest
if not width_found:
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm
        wvl_n = 2
        wvl_simulated = np.linspace(wvl_min, wvl_max, wvl_n)
        frq_simulated = 1000 / wvl_simulated
        
        # Geometry parameters
        sim_length = 5
        sim_width = 5
        sim_resolution = 40
        wvg_neff = 3
        cld_neff = 1.3
        
        # Define different waveguide widths to test
        wvg_widths = [0.4, 0.35, 0.3, 0.25, 0.2]  # You can modify this list
        
        # Create figure with two subplots side by side
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))
    
        # Loop through both wavelengths
        for frq_idx, frq in enumerate(frq_simulated):
                # Select the appropriate subplot
                ax = ax1 if frq_idx == 0 else ax2
                
                # Loop through different waveguide widths
                for wvg_width in wvg_widths:
                        geometry = [
                        mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                                center=mp.Vector3(),
                                material=mp.Medium(epsilon=cld_neff**2)),
                        mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                                center=mp.Vector3(),
                                material=mp.Medium(epsilon=wvg_neff**2))]
            
                        # Mode found
                        Ez1_cross, Hy1_cross, neff = SL.finding_mode_from_geometry(geometry, 
                                                                                frequency=frq,
                                                                                mode=2,
                                                                                resolution=sim_resolution)
                
                        # Define axis of the mode
                        cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross))
                
                        # Plotting with different colors/styles for each width
                        ax.plot(cross_axis, Ez1_cross, 
                                label=f'w={wvg_width}μm, neff={neff:.3f}', 
                                linewidth=2)
        
                # Configure subplot with larger fonts
                plt_fontsize = 16
                ax.set_title(f'Ez Mode Profile {frq:.3f} THz/c', fontsize=plt_fontsize, fontweight='bold')
                ax.set_xlabel('Position [μm]', fontsize=plt_fontsize)
                ax.set_ylabel('Normalized Field', fontsize=plt_fontsize)
                ax.legend(fontsize=plt_fontsize, loc='best')
                ax.grid(True, alpha=0.3)
                ax.tick_params(axis='both', which='major', labelsize=plt_fontsize)
    
        # Show the plot
        plt.show()

#################################################################
###  2 - Find waveguide modes for all wavelengths of interest ###
#################################################################
if not mode_calculated:
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm 
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Geometry parameters
        sim_length = 5
        sim_width = 5 if mode_calculated_kind == 'wvg' else 20
        sim_resolution = 40
        wvg_neff = 3 if mode_calculated_kind == 'wvg' else 1.46
        cld_neff = 1.3 if mode_calculated_kind == 'wvg' else 1.44

        # Define fixed waveguide width
        wvg_width = 0.3 if mode_calculated_kind == 'wvg' else 4.5

        # Create single figure
        fig, ax = plt.subplots(1, 1, figsize=(12, 8))

        # Loop through all frequencies
        for frq_idx, frq in enumerate(frq_simulated):
                geometry = [
                mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=cld_neff**2)),
                mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=wvg_neff**2))]

                # Mode found
                Ez1_cross, Hy1_cross, neff = SL.finding_mode_from_geometry(geometry, 
                                                                        frequency=frq,
                                                                        mode=1,
                                                                        resolution=sim_resolution)

                # Define axis of the mode
                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross))

                # Plotting with different colors for each wavelength
                ax.plot(cross_axis, Ez1_cross, 
                        label=f'f={frq:.3f}nm, neff={neff:.3f}', 
                        linewidth=2)

                # Saving individual data files for each wavelength
                data = {
                "Ez": Ez1_cross.tolist(),
                "Hy": Hy1_cross.tolist(),
                "neff": float(neff),
                "cross_axis": cross_axis.tolist(),
                "wvg_width": float(wvg_width),
                "frequency": float(frq)
                }

                # Save individual file
                file_name_wvg = f"Output/Mode_ex_width{wvg_width}_frequency{frq:.3f}nm.json"
                file_name_fiber = f"Output/Mode_ex_fiber_frequency{frq:.3f}nm.json"
                with open(file_name_wvg if mode_calculated_kind == 'wvg' else file_name_fiber, "w") as f:
                        json.dump(data, f)

                # Configure plot with larger fonts
                plt_fontsize = 16
                title_name_wvg = f"Ez Mode Profile for Width={wvg_width}μm at Different Wavelengths"
                title_name_fiber = f"Ez Mode Profile for Fiber at Different Wavelengths"
                ax.set_title(title_name_wvg if mode_calculated_kind == 'wvg' else title_name_fiber, 
                        fontsize=plt_fontsize, fontweight='bold')
                ax.set_xlabel('Position [μm]', fontsize=plt_fontsize)
                ax.set_ylabel('Normalized Field', fontsize=plt_fontsize)
                ax.legend(fontsize=plt_fontsize, loc='best')  
                ax.grid(True, alpha=0.3)
                ax.tick_params(axis='both', which='major', labelsize=plt_fontsize)

        # Show the plot
        plt.show()

#################################################################
###  3 - Propagate waveguide and calculate overlap with mode  ###
#################################################################
if not propagation_waveguide:
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm 
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Geometry parameters
        sim_length = 50
        sim_width = 5
        sim_resolution = 20
        pml_thickness = 1
        wvg_neff = 3
        cld_neff = 1.3

        # Define fixed waveguide width
        wvg_width = 0.3 

        # Create the geometry
        geometry = [
                mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=cld_neff**2)),
                mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=wvg_neff**2))]
        
        # Calculate the cell size and position
        cell_size, cell_center = SL.compute_geometry_bounds(geometry)

        # Boundary condition
        pml_layers = [mp.PML(pml_thickness)]
        
        # Create the sources joining all the frequencies
        sources = []
        Ez1_cross_array = []
        Hy1_cross_array = []
        for frq in frq_simulated:
                # Load mode from previous calculated one
                with open(f"Output/Mode_ex_width{wvg_width}_frequency{frq:.3f}nm.json", "r") as f:
                        data = json.load(f)
                        Ez1_cross = np.array(data["Ez"])
                        Hy1_cross = np.array(data["Hy"])
                        neff = data["neff"]
                        cross_axis = np.array(data["cross_axis"])

                        # Append to array
                        Ez1_cross_array.append(Ez1_cross)
                        Hy1_cross_array.append(Hy1_cross)

                # Create a source from the mode fields
                source = SL.generate_modal_source(Ez_cross = Ez1_cross,
                                                Hy_cross = Hy1_cross,
                                                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross)),
                                                src_position = mp.Vector3(-sim_length / 2 + pml_thickness, 0),
                                                src_size=mp.Vector3(0, sim_width),
                                                frequency=frq)
                
                sources.append(source[0])
                sources.append(source[1])

        # Simulation settings
        sim = mp.Simulation(
                cell_size=cell_size,
                sources=sources,
                geometry=geometry,
                resolution=sim_resolution,
                boundary_layers=pml_layers
        )

        # Define DFT fields to be recorded
        dft = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, 
                                                where=mp.Volume(center=mp.Vector3(),
                                                size=cell_size))

        # Run the simulation
        sim.run(until=sim_length*wvg_neff*2)
        
        # Visualize the geometry simulated
        eps_data = sim.get_array(center=mp.Vector3(0, 0, 0), 
                                size=cell_size, 
                                component=mp.Dielectric)

        # Create figure with two subplots
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
        
        # LEFT SUBPLOT - Field Propagation Visualization
        # Plot the material structure
        ax1.imshow(eps_data.transpose(), interpolation='spline36', 
                   cmap='binary', aspect='auto', extent=(0, sim_length, 0, sim_width))
        overlap_axis = np.linspace(-sim_length/2, sim_length/2, len(eps_data))

        # Extract the fields at the DFT region and compute overlaps
        for idx, frq in enumerate(frq_simulated):
                ez_data = sim.get_dft_array(dft, mp.Ez, idx)
                hy_data = sim.get_dft_array(dft, mp.Hy, idx)
                
                # Overlay field on the left subplot (using transparency to show all)
                ax1.imshow(np.abs(ez_data).transpose(), interpolation='spline36', 
                        cmap='RdBu', alpha=1/wvl_n, aspect='auto', 
                        extent=(0, sim_length, 0, sim_width))
                
                # Create field axis for the cross section
                field_axis = np.linspace(-sim_width/2, sim_width/2, len(ez_data[0]))
                
                # Calculate overlap
                overlap, _ = SL.calculate_modal_overlap(Ez_cross = Ez1_cross_array[idx], 
                                                Hy_cross = Hy1_cross_array[idx], 
                                                Ez_field = ez_data, 
                                                Hy_field = hy_data,
                                                cross_axis = cross_axis,
                                                field_axis = field_axis)
                
                # Add overlap to the plot
                ax2.plot(overlap_axis, overlap, label=f"frq {frq:.3f} THz/c")
                
        # Configure left subplot
        plt_fontsize = 16
        ax1.set_title('Field Propagation (Ez)', fontsize=plt_fontsize, fontweight='bold')
        ax1.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax1.set_ylabel('Width [μm]', fontsize=plt_fontsize)
        ax1.axis('off')
        
        # Add scale bar or position markers
        ax1.axvline(x=pml_thickness, color='white', linestyle='--', alpha=0.5, linewidth=1)
        ax1.axvline(x=sim_length-pml_thickness, color='white', linestyle='--', alpha=0.5, linewidth=1)
        ax1.text(x=-3*pml_thickness+sim_length, y=4, s='PML', color='white', fontsize=plt_fontsize, rotation=90)
        
        # RIGHT SUBPLOT - Overlap
        ax2.set_xlabel('Distance [μm]', fontsize=plt_fontsize)
        ax2.set_ylabel('Modal Overlap', fontsize=plt_fontsize)
        ax2.set_title('Modal Overlap vs Wavelength', fontsize=plt_fontsize, fontweight='bold')
        ax2.grid(True, alpha=0.3)
        ax2.legend()
        
        # Overall title
        fig.suptitle(f'Waveguide Propagation Analysis (Width = {wvg_width}μm)', 
                        fontsize=16, fontweight='bold')
        
        plt.show()

#################################################################
###  4 - Propagate light in a coupler to see its overlap      ###
#################################################################
if not propagation_coupler:
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm 
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Geometry parameters
        sim_length = 50
        sim_width = 5
        sim_resolution = 20
        pml_thickness = 1
        wvg_neff = 3
        cld_neff = 1.3

        # Define fixed waveguide width
        wvg_width = 0.3 
        coupler_gap = 0.3

        # Create the geometry
        geometry = [
                mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=cld_neff**2)),
                mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                        center=mp.Vector3(0, coupler_gap/2+wvg_width/2),
                        material=mp.Medium(epsilon=wvg_neff**2)),
                mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                        center=mp.Vector3(0, -coupler_gap/2-wvg_width/2),
                        material=mp.Medium(epsilon=wvg_neff**2))]

        # Calculate the cell size and position
        cell_size, cell_center = SL.compute_geometry_bounds(geometry)

        # Boundary condition
        pml_layers = [mp.PML(pml_thickness)]

        # Create the sources joining all the frequencies
        sources = []
        Ez1_cross_array = []
        Hy1_cross_array = []
        for frq in frq_simulated:
                # Load mode from previous calculated one
                with open(f"Output/Mode_ex_width{wvg_width}_frequency{frq:.3f}nm.json", "r") as f:
                        data = json.load(f)
                        Ez1_cross = np.array(data["Ez"])
                        Hy1_cross = np.array(data["Hy"])
                        neff = data["neff"]
                        cross_axis = np.array(data["cross_axis"])

                # Append to array
                Ez1_cross_array.append(Ez1_cross)
                Hy1_cross_array.append(Hy1_cross)

                # Create a source from the mode fields
                source = SL.generate_modal_source(Ez_cross = Ez1_cross,
                                                Hy_cross = Hy1_cross,
                                                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross)),
                                                src_position = mp.Vector3(-sim_length / 2 + pml_thickness, coupler_gap/2+wvg_width/2),
                                                src_size=mp.Vector3(0, sim_width),
                                                frequency=frq)

                sources.append(source[0])
                sources.append(source[1])

        # Simulation settings
        sim = mp.Simulation(
                cell_size=cell_size,
                sources=sources,
                geometry=geometry,
                resolution=sim_resolution,
                boundary_layers=pml_layers)

        # Define DFT fields to be recorded
        dft = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, 
                                        where=mp.Volume(center=mp.Vector3(),
                                        size=cell_size))

        # Run the simulation
        sim.run(until=sim_length*wvg_neff*2)

        # Visualize the geometry simulated
        eps_data = sim.get_array(center=mp.Vector3(0, 0, 0), 
                                size=cell_size, 
                                component=mp.Dielectric)

        # Create figure with two subplots
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

        # LEFT SUBPLOT - Field Propagation Visualization
        # Plot the material structure
        ax1.imshow(eps_data.transpose(), interpolation='spline36', cmap='binary', aspect='auto',
                   extent=(0, sim_length, 0, sim_width))
        overlap_axis = np.linspace(0, sim_length, len(eps_data))

        # Extract the fields at the DFT region and compute overlaps
        for idx, frq in enumerate(frq_simulated):
                ez_data = sim.get_dft_array(dft, mp.Ez, idx)
                hy_data = sim.get_dft_array(dft, mp.Hy, idx)

                # Overlay field on the left subplot (using transparency to show all)
                ax1.imshow(np.abs(ez_data).transpose(), interpolation='spline36', 
                                cmap='RdBu', alpha=0.1, aspect='auto',
                                extent=(0, sim_length, 0, sim_width))

                # Create field axis for the cross section
                field_axis = np.linspace(-sim_width/2, sim_width/2, len(ez_data[0]))

                # Calculate overlap
                overlap, _ = SL.calculate_modal_overlap(Ez_cross = Ez1_cross_array[idx], 
                                                Hy_cross = Hy1_cross_array[idx], 
                                                Ez_field = ez_data, 
                                                Hy_field = hy_data,
                                                cross_axis = cross_axis + coupler_gap / 2 + wvg_width / 2,
                                                field_axis = field_axis)

                # Add overlap to the plot
                ax2.plot(overlap_axis, overlap, label=f"frq {frq:.3f} nm")

        # Configure left subplot
        plt_fontsize = 16
        ax1.set_title('Field Propagation (Ez)', fontsize=plt_fontsize, fontweight='bold')
        ax1.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax1.set_ylabel('Width [μm]', fontsize=plt_fontsize)
        ax1.axis('off')

        # Add scale bar or position markers
        ax1.axvline(x=pml_thickness, color='white', linestyle='--', alpha=0.5, linewidth=1)
        ax1.axvline(x=sim_length-pml_thickness, color='white', linestyle='--', alpha=0.5, linewidth=1)
        ax1.text(x=-3*pml_thickness+sim_length, y=4, s='PML', color='white', fontsize=plt_fontsize, rotation=90)

        # RIGHT SUBPLOT - Overlap
        ax2.set_xlabel('Distance [μm]', fontsize=plt_fontsize)
        ax2.set_ylabel('Modal Overlap', fontsize=plt_fontsize)
        ax2.set_title('Modal Overlap vs Wavelength', fontsize=plt_fontsize, fontweight='bold')
        ax2.tick_params(axis='x', labelsize=plt_fontsize)
        ax2.tick_params(axis='y', labelsize=plt_fontsize)
        ax2.grid(True, alpha=0.3)
        ax2.legend()

        # Overall title
        fig.suptitle(f'Waveguide Propagation Analysis (Width = {wvg_width}μm)', 
                fontsize=16, fontweight='bold')

        plt.show()

#################################################################
###  5 - Propagate light in a MMI to see its overlap          ###
#################################################################
if not propagation_mmi:
        # Define mmi length to simulate
        mmi_lengths = [20, 8.5, 8.75, 9, 9.25, 9.5]   #(μm)

        # Fixed spectral parameters
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Fixed simulation/global parameters
        sim_width = 5
        sim_resolution = 30
        pml_thickness = 1
        wvg_neff = 3
        cld_neff = 1.3
        mmi_width = 3
        wvg_width = 0.3
        wvg_input_mmi_width = 0.8
        mmi_output_shift = mmi_width / 4

        # Boundary condition
        pml_layers = [mp.PML(pml_thickness)]

        # Perform the same operation on different mmi_lengths
        results = []
        for mmi_length in mmi_lengths:
                # Adjust length to have enough space for waveguide
                sim_length = mmi_length + 35
                wvg_length = (sim_length - mmi_length) / 2

                # Geometry
                geometry = [
                        mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                                center=mp.Vector3(),
                                material=mp.Medium(epsilon=cld_neff**2)),

                        # Input Taper (replaces the first waveguide Block)
                        mp.Prism(
                                vertices=[
                                mp.Vector3(-mmi_length / 2 - wvg_length, -wvg_width/2),
                                mp.Vector3(-mmi_length / 2, -wvg_input_mmi_width/2),
                                mp.Vector3(-mmi_length / 2, wvg_input_mmi_width/2),
                                mp.Vector3(-mmi_length / 2 - wvg_length, wvg_width/2)],
                                height=mp.inf, 
                                material=mp.Medium(epsilon=wvg_neff**2)
                        ),

                        # Top Output Taper (replaces one output waveguide Block)
                        mp.Prism(
                                vertices=[
                                mp.Vector3(mmi_length / 2, mmi_output_shift - wvg_input_mmi_width/2),
                                mp.Vector3(mmi_length / 2 + wvg_length, mmi_output_shift - wvg_width/2),
                                mp.Vector3(mmi_length / 2 + wvg_length, mmi_output_shift + wvg_width/2),
                                mp.Vector3(mmi_length / 2, mmi_output_shift + wvg_input_mmi_width/2)],
                                height=mp.inf,
                                material=mp.Medium(epsilon=wvg_neff**2)
                        ),

                        # Bottom Output Taper (replaces the other output waveguide Block)
                        mp.Prism(
                                vertices=[
                                mp.Vector3(mmi_length / 2, -mmi_output_shift - wvg_input_mmi_width/2),
                                mp.Vector3(mmi_length / 2 + wvg_length, -mmi_output_shift - wvg_width/2),
                                mp.Vector3(mmi_length / 2 + wvg_length, -mmi_output_shift + wvg_width/2),
                                mp.Vector3(mmi_length / 2, -mmi_output_shift + wvg_input_mmi_width/2)],
                                height=mp.inf,
                                material=mp.Medium(epsilon=wvg_neff**2)
                        ),

                        # MMI part
                        mp.Block(size=mp.Vector3(mmi_length, mmi_width, 0),
                                center=mp.Vector3(),
                                material=mp.Medium(epsilon=wvg_neff**2)),
                        
                ]
                
                # Compute the geometry boundary
                cell_size, cell_center = SL.compute_geometry_bounds(geometry)

                # Load mode fields & build sources (per frequency)
                Ez1_cross_array = []
                Hy1_cross_array = []
                sources = []

                for frq in frq_simulated:
                        # Load the file
                        with open(f"Output/Mode_ex_width{wvg_width}_frequency{frq:.3f}nm.json", "r") as f:
                                data = json.load(f)
                                
                                # Extract the files
                                Ez1_cross = np.array(data["Ez"])
                                Hy1_cross = np.array(data["Hy"])
                                Ez1_cross_array.append(Ez1_cross)
                                Hy1_cross_array.append(Hy1_cross)
                                cross_axis = data['cross_axis']
                                
                                # Create the source of the simulation
                                source = SL.generate_modal_source(
                                        Ez_cross=Ez1_cross,
                                        Hy_cross=Hy1_cross,
                                        cross_axis=cross_axis,
                                        src_position=mp.Vector3(-sim_length/2 + pml_thickness),
                                        src_size=mp.Vector3(0, sim_width),
                                        frequency=frq)

                                sources.append(source[0])
                                sources.append(source[1])
                
                # Fixed Simulation settings
                sim = mp.Simulation(
                cell_size=cell_size,
                sources=sources,
                geometry=geometry,
                resolution=sim_resolution,
                boundary_layers=pml_layers)

                # Times
                t_overlap = wvg_length * wvg_neff * 1.2
                t_total   = sim_length * wvg_neff * 2.0

                # Volumes
                vol_input = mp.Volume(
                        center=mp.Vector3(-sim_length/2 + wvg_length/2, 0),
                        size=mp.Vector3(wvg_length, sim_width, 0))

                vol_total = mp.Volume(
                        center=mp.Vector3(wvg_length/2),
                        size=mp.Vector3(sim_length-wvg_length, sim_width, 0))

                # Stage 1 DFT
                dft_in = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, where=vol_input)
                sim.run(until=t_overlap)

                Ez_in_list = [sim.get_dft_array(dft_in, mp.Ez, i) for i in range(wvl_n)]
                Hy_in_list = [sim.get_dft_array(dft_in, mp.Hy, i) for i in range(wvl_n)]

                # Stage 2 DFT
                dft_out = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, where=vol_total)
                sim.run(until=t_total)
                Ez_out_list = [sim.get_dft_array(dft_out, mp.Ez, i) for i in range(wvl_n)]
                Hy_out_list = [sim.get_dft_array(dft_out, mp.Hy, i) for i in range(wvl_n)]

                # Material for plotting
                eps_data = sim.get_array(center=mp.Vector3(0, 0, 0),
                                        size=cell_size,
                                        component=mp.Dielectric)

                # Axes/discretization (recomputed because wvg_length depends on mmi_length)
                n_points_input_wvg  = int(round(wvg_length * sim_resolution))
                n_points_mmi        = int(round(mmi_length * sim_resolution))
                n_points_output_wvg = int(round(wvg_length * sim_resolution))
                total_points        = n_points_input_wvg + n_points_mmi + n_points_output_wvg

                overlap_axis = np.linspace(0, sim_length, total_points)
                field_axis = np.linspace(-sim_width/2, sim_width/2, sim_width * sim_resolution)
                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross))

                # Compute overlaps for each frequency (store final curves)
                overlap_totals = []
                Ez_list = []
                for idx in range(wvl_n):
                        # Extract the field calculated
                        Ez_in  = Ez_in_list[idx]
                        Hy_in  = Hy_in_list[idx]
                        Ez_out = Ez_out_list[idx]
                        Hy_out = Hy_out_list[idx]
                        Ez = np.concatenate([Ez_in, Ez_out], axis=0)
                        Ez_list.append(Ez)
                        
                        # Initialize the overlap
                        overlap_total = np.zeros(total_points)

                        # Calculate the overlap at the input
                        overlap_in, field_norm = SL.calculate_modal_overlap(
                                Ez_cross=Ez1_cross_array[idx],
                                Hy_cross=Hy1_cross_array[idx],
                                Ez_field=Ez_in,
                                Hy_field=Hy_in,
                                cross_axis=cross_axis,
                                field_axis=field_axis)
                        overlap_total[:n_points_input_wvg] = overlap_in[:n_points_input_wvg]
                        
                        # The overlap at the MMI is set to 0 since does not make sense
                        overlap_total[n_points_input_wvg:n_points_input_wvg + n_points_mmi] = 0

                        # Calculate the overlap a
                        overlap_out, _ = SL.calculate_modal_overlap(
                                Ez_cross=Ez1_cross_array[idx],
                                Hy_cross=Hy1_cross_array[idx],
                                Ez_field=Ez_out,
                                Hy_field=Hy_out,
                                cross_axis=cross_axis + mmi_output_shift,
                                field_axis=field_axis,
                                field_norm=field_norm)
                        
                        overlap_total[(len(overlap_total)-len(overlap_out[n_points_mmi:])):] = overlap_out[n_points_mmi:]
                        overlap_totals.append(overlap_total)

                # Build a single overlay image (so we can update one artist instead of stacking many)
                Ez_overlay = np.sum([np.abs(Ez) for Ez in Ez_list], axis=0)

                results.append({
                        "mmi_length": mmi_length,
                        "wvg_length": wvg_length,
                        "eps_data": eps_data,
                        "Ez_overlay": Ez_overlay,
                        "overlap_axis": overlap_axis,
                        "overlap_totals": overlap_totals,  
                        "field_axis": field_axis})

        # Initialize the plot
        plt_fontsize = 16
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
        
        # Initialize the state of the plot
        state = {"k": 0} 

        # Initialize with first result
        r0 = results[0]
        
        # Create the first image (material + field)
        eps_im = ax1.imshow(r0["eps_data"].transpose(),
                        interpolation='spline36', cmap='binary', aspect='auto',
                        extent=(0, sim_length, 0, sim_width))

        field_im = ax1.imshow(r0["Ez_overlay"].transpose(),
                        interpolation='spline36', cmap='RdBu',
                        aspect='auto', alpha=1,
                        extent=(0, sim_length, 0, sim_width))

        # Setting of first axis
        ax1.set_title('Geometry', fontsize=plt_fontsize, fontweight='bold')
        ax1.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax1.set_ylabel('Width [μm]', fontsize=plt_fontsize)
        ax1.axis('off')

        # Plot of the second axis
        lines = []
        for idx, frq in enumerate(frq_simulated):
                (ln,) = ax2.plot(r0["overlap_axis"], r0["overlap_totals"][idx],
                                label=f"{frq:.3f} Thz/c")
                lines.append(ln)
        
        # Setting of the second axis
        vline1 = ax2.axvline(x=r0["wvg_length"], color='gray', linestyle='--', alpha=0.5, linewidth=1)
        vline2 = ax2.axvline(x=r0["wvg_length"] + r0["mmi_length"], color='gray', linestyle='--', alpha=0.5, linewidth=1)
        ax2.set_xlabel('Distance [μm]', fontsize=plt_fontsize)
        ax2.set_ylabel('Modal Overlap', fontsize=plt_fontsize)
        ax2.set_title('Modal Overlap (2-stage run)', fontsize=plt_fontsize, fontweight='bold')
        ax2.tick_params(axis='both', which='major', labelsize=plt_fontsize)
        ax2.grid(True, alpha=0.3)
        ax2.legend()
        ax2.set_ylim(-0.1, 1.1) 

        fig.suptitle(f'Waveguide Propagation Analysis (Width = {wvg_width} μm) | MMI length = {r0["mmi_length"]} μm',
                fontsize=16, fontweight='bold')

        # Create a function to change resulting plot
        def update_plot(k):
                # Take results 
                r = results[k]

                # Recreate the image
                eps_im.set_data(r["eps_data"].transpose())
                field_im.set_data(r["Ez_overlay"].transpose())

                # Recreate the overlap
                for i, ln in enumerate(lines):
                        ln.set_data(r["overlap_axis"], r["overlap_totals"][i])
                vline1.set_xdata([r["wvg_length"], r["wvg_length"]])
                vline2.set_xdata([r["wvg_length"] + r["mmi_length"], r["wvg_length"] + r["mmi_length"]])

                # Redraw and change settings
                ax2.relim()
                ax2.autoscale_view()
                fig.suptitle(f'Waveguide Propagation Analysis (Width = {wvg_width} μm) | MMI length = {r["mmi_length"]} μm',
                                fontsize=16, fontweight='bold')
                fig.canvas.draw_idle()

        # Right button
        btn_ax_right = fig.add_axes([0.92, 0.475, 0.06, 0.08])
        btn_right = Button(btn_ax_right, "", color="white", hovercolor="0.9")

        # Left button (slightly outside)
        btn_ax_left = fig.add_axes([0.02, 0.475, 0.06, 0.08])
        btn_left = Button(btn_ax_left, "", color="white", hovercolor="0.9")

        # Right-pointing triangle
        tri_right = plt.Polygon(
                [[0.30, 0.20], [0.30, 0.80], [0.75, 0.50]],
                closed=True,
                transform=btn_ax_right.transAxes,
                facecolor="black",
                edgecolor="black")
        btn_ax_right.add_patch(tri_right)

        # Left-pointing triangle (mirrored)
        tri_left = plt.Polygon(
                [[0.70, 0.20], [0.70, 0.80], [0.25, 0.50]],
                closed=True,
                transform=btn_ax_left.transAxes,
                facecolor="black",
                edgecolor="black")
        btn_ax_left.add_patch(tri_left)

        # Clean button axes
        for ax in (btn_ax_right, btn_ax_left):
                _ = ax.set_xticks([])
                _ = ax.set_yticks([])
        for spine in ax.spines.values():
                spine.set_visible(False)

        # Callbacks
        def on_button_right(event):
                state["k"] = (state["k"] + 1) % len(results)
                update_plot(state["k"])

        def on_button_left(event):
                state["k"] = (state["k"] - 1) % len(results)
                update_plot(state["k"])

        _ = btn_right.on_clicked(on_button_right)
        _ = btn_left.on_clicked(on_button_left)

        plt.show()
        
#################################################################
###  6 - Propagate light in a subresolution taper             ###
#################################################################
if not propagation_taper:
        # Fixed spectral parameters
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Fixed simulation parameters for waveguide
        wvg_width_start = 0.3
        wvg_width_end = 1.5
        taper_length = 30
        wvg_strt_length = 20
        wvg_neff = 3
        cld_neff = 1.3

        # Fixed simulation parameters for fiber
        fiber_distance = 0.5
        fiber_length = 20
        fiber_core_width = 4.5
        fiber_core_neff = 1.46
        fiber_cld_neff = 1.44

        # Fixed simulation parameters for simulation
        sim_width = 10
        sim_length = taper_length + 2*wvg_strt_length + fiber_distance + fiber_length
        sim_resolution = 30
        pml_thickness = 1

        # Parameters for the no-reflection simulation
        n_dft = 30          # total monitors
        n_active = 5        # max simultaneous monitors
        dx = (sim_length - 2*pml_thickness) / n_dft

        # Boundary condition
        pml_layers = [mp.PML(pml_thickness)]

        # Define the taper vertices
        vertices = [mp.Vector3(0, -wvg_width_start/2),
                        mp.Vector3(wvg_strt_length, -wvg_width_start/2),
                        mp.Vector3(wvg_strt_length+taper_length, -wvg_width_end/2),
                        mp.Vector3(2*wvg_strt_length+taper_length, -wvg_width_end/2),
                        mp.Vector3(2*wvg_strt_length+taper_length, wvg_width_end/2),
                        mp.Vector3(wvg_strt_length+taper_length, wvg_width_end/2),
                        mp.Vector3(wvg_strt_length, wvg_width_start/2),
                        mp.Vector3(0, wvg_width_start/2)]

        # Transform the vertices in a material grid
        material_grid = SL.polygon_to_materialgrid(vertices=vertices,
                                                        medium_outside=mp.Medium(epsilon=cld_neff**2),
                                                        medium_inside=mp.Medium(epsilon=wvg_neff**2),
                                                        y_axis = [-sim_width/2, sim_width/2])

        # Geometry definition
        geometry = [mp.Block(size=mp.Vector3(sim_length-fiber_distance-fiber_length, sim_width, 0),
                                center=mp.Vector3(-fiber_distance/2-fiber_length/2),
                                material=material_grid),
                        
                        # Air
                        mp.Block(size=mp.Vector3(fiber_length+fiber_distance, sim_width, 0),
                                center=mp.Vector3(-sim_length/2+2*wvg_strt_length+taper_length+fiber_distance/2+fiber_length/2),
                                material=mp.Medium(epsilon=1)),

                        # Fiber
                        mp.Block(size=mp.Vector3(fiber_length, sim_width, 0),
                                center=mp.Vector3(-sim_length/2+2*wvg_strt_length+taper_length+fiber_distance+fiber_length/2),
                                material=mp.Medium(epsilon=fiber_cld_neff**2)),
                        mp.Block(size=mp.Vector3(fiber_length, fiber_core_width, 0),
                                center=mp.Vector3(-sim_length/2+2*wvg_strt_length+taper_length+fiber_distance+fiber_length/2),
                                material=mp.Medium(epsilon=fiber_core_neff**2))]

        # Compute the geometry boundary
        cell_size, cell_center = SL.compute_geometry_bounds(geometry)

        # Load mode fields & build sources (per frequency)
        Ez1_fiber_array = []
        Hy1_fiber_array = []
        mode_sources = []

        # For every frequency
        for frq in frq_simulated:
                # Load the file for creating mode in input
                with open(f"Output/Mode_ex_width{wvg_width_start}_frequency{frq:.3f}nm.json", "r") as f:
                        data = json.load(f)
                        
                        # Extract the files
                        Ez1_cross = np.array(data["Ez"])
                        Hy1_cross = np.array(data["Hy"])
                        mode_cross_axis = np.array(data['cross_axis'])
                        neff = data['neff']
                        o = SL.calculate_modal_overlap(Ez1_cross,
                                                   Hy1_cross,
                                                   [Ez1_cross],
                                                   [Hy1_cross])
                        # Create the source of the simulation
                        source = SL.generate_modal_source(
                                Ez_cross=Ez1_cross,
                                Hy_cross=Hy1_cross,
                                cross_axis=mode_cross_axis,
                                src_position=mp.Vector3(-sim_length/2 + pml_thickness),
                                src_size=mp.Vector3(0, sim_width),
                                frequency=frq)

                        mode_sources.append(source[0])
                        mode_sources.append(source[1])

                # Load the file to calculate fiber overlap
                with open(f"Output/Mode_ex_fiber_frequency{frq:.3f}nm.json", "r") as f:
                        data = json.load(f)
                        
                        # Extract the files
                        Ez1_fiber = np.array(data["Ez"])
                        Hy1_fiber = np.array(data["Hy"])
                        Ez1_fiber_array.append(Ez1_fiber)
                        Hy1_fiber_array.append(Hy1_fiber)
                        fiber_cross_axis = np.array(data['cross_axis'])

        # Fixed Simulation settings
        sim = mp.Simulation(
        cell_size=cell_size,
        sources=mode_sources,
        geometry=geometry,
        resolution=sim_resolution,
        boundary_layers=pml_layers)

        # Run simulation with regular method
        dft = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, 
                                        where=mp.Volume(center=mp.Vector3(),
                                        size=cell_size))
        sim.run(until=sim_length*wvg_neff)

        # Extract electric and magnetic field
        Ez_array_prev = {}
        Hy_array_prev = {}
        for idx, frequency in enumerate(frq_simulated):
                Ez_array_prev[frequency] = sim.get_dft_array(dft, mp.Ez, idx)
                Hy_array_prev[frequency] = sim.get_dft_array(dft, mp.Hy, idx)

        # Reset simulation
        sim.reset_meep()

        # Run simulation without reflection and extract electric and magnetic field
        Ez_array, Hy_array = SL.simulate_without_reflections(simulation=sim,
                                                        number_windows=n_dft,
                                                        max_active_windows=n_active,
                                                        window_volume=mp.Volume(size=mp.Vector3(dx, sim_width),
                                                                                center=mp.Vector3(-sim_length/2 + dx/2)),
                                                        frequencies=frq_simulated)

        # Get material data from simulation
        eps_data = sim.get_array(center=mp.Vector3(0, 0, 0),
                                size=cell_size,
                                component=mp.Dielectric)

        # Define the Transverse Axis for the integral calculation
        field_axis_y = np.linspace(-sim_width/2, sim_width/2, int(sim_width * sim_resolution))

        # Setup the Figure (2 Rows, 2 Cols)
        fig, axes = plt.subplots(2, 2, figsize=(14, 8), constrained_layout=True)

        # Define axes for easier access
        # LEFT COLUMN: Standard Method
        ax_std_field   = axes[0, 0] 
        ax_std_overlap = axes[1, 0] 

        # RIGHT COLUMN: No-Reflection Method
        ax_slide_field   = axes[0, 1] 
        ax_slide_overlap = axes[1, 1] 

        # Plot Geometry
        ax_std_field.imshow(eps_data.transpose(),
                        interpolation='spline36', cmap='binary', aspect='auto',
                        extent=(0, sim_length, 0, sim_width))

        # Plot Fields
        im_std = None
        for frequency in frq_simulated:
                im_std = ax_std_field.imshow(np.abs(Ez_array_prev[frequency]).T,
                                                aspect='auto', cmap='RdBu', interpolation='spline36', alpha=0.9,
                                                extent=(0, sim_length, 0, sim_width)) # Standard covers whole cell

        ax_std_field.set_title("Standard Simulation: |Ez|")
        ax_std_field.set_ylabel("Transverse (y)")
        ax_std_field.set_xlabel("Propagation (x)")
        ax_std_field.set_xlim(0, sim_length)
        ax_std_field.set_ylim(0, sim_width)
        fig.colorbar(im_std, ax=ax_std_field, label="|Ez|")

        # Overlap Plot
        for idf, frq in enumerate(frq_simulated):
                # Calculate Overlap
                overlap, _ = SL.calculate_modal_overlap(
                        Ez_cross=Ez1_fiber_array[idf],
                        Hy_cross=Hy1_fiber_array[idf],
                        Ez_field=Ez_array_prev[frq],
                        Hy_field=Hy_array_prev[frq],
                        cross_axis=fiber_cross_axis,
                        field_axis=field_axis_y)

                # X-axis covers the whole simulation length (0 to L)
                prop_axis_std = np.linspace(0, sim_length, len(overlap))
                ax_std_overlap.plot(prop_axis_std, overlap, label=f"Freq: {frq:.3f}")

        ax_std_overlap.set_title("Standard: Modal Overlap")
        ax_std_overlap.set_xlabel("Propagation distance (x)")
        ax_std_overlap.set_ylabel("Normalized Overlap")
        ax_std_overlap.grid(True)
        ax_std_overlap.legend()

        # Field Map
        # Plot Geometry (Same background)
        ax_slide_field.imshow(eps_data.transpose(),
                        interpolation='spline36', cmap='binary', aspect='auto',
                        extent=(0, sim_length, 0, sim_width))

        # Plot Fields
        im_slide = None
        for frequency in frq_simulated:
                # Note: Extent is (pml_thickness, sim_length-pml_thickness) because
                # the sliding window function typically calculates the inner region
                im_slide = ax_slide_field.imshow(np.abs(Ez_array[frequency]).T,
                                                aspect='auto', cmap='RdBu', interpolation='spline36', alpha=0.7,
                                                extent=(pml_thickness, sim_length-pml_thickness, 0, sim_width))

        ax_slide_field.set_title("No-Reflection (Sliding): |Ez|")
        ax_slide_field.set_ylabel("Transverse (y)")
        ax_slide_field.set_xlabel("Propagation (x)")
        ax_slide_field.set_xlim(0, sim_length)
        ax_slide_field.set_ylim(0, sim_width)
        fig.colorbar(im_slide, ax=ax_slide_field, label="|Ez|")

        # Overlap Plot
        for idf, frq in enumerate(frq_simulated):
                # Calculate Overlap
                overlap, _ = SL.calculate_modal_overlap(
                        Ez_cross=Ez1_fiber_array[idf],
                        Hy_cross=Hy1_fiber_array[idf],
                        Ez_field=Ez_array[frq],
                        Hy_field=Hy_array[frq],
                        cross_axis=fiber_cross_axis,
                        field_axis=field_axis_y)
        
                # X-axis covers only the stitched region (PML to L-PML)
                prop_axis_slide = np.linspace(pml_thickness, sim_length-pml_thickness, len(overlap))
                ax_slide_overlap.plot(prop_axis_slide, overlap, label=f"Freq: {frq:.3f}")

        ax_slide_overlap.set_title("No-Reflection: Modal Overlap")
        ax_slide_overlap.set_xlabel("Propagation distance (x)")
        ax_slide_overlap.set_ylabel("Normalized Overlap")
        ax_slide_overlap.grid(True)
        ax_slide_overlap.legend()

        plt.show()

        
#################################################################
###  7 - Propagate bend waveguide and calculate overlap       ###
#################################################################
if not propagation_curve:
        # Wavelength and frequency parameters
        wvl = 1550  # nm
        frq = 1000 / wvl
        
        # Geometry parameters
        sim_resolution = 20
        n_circle_vertex = 50
        bnd_width = 3
        sub_pixel = 20
        wvg_width = 0.3
        wvg_neff = 3
        cld_neff = 1.3
        sim_width = bnd_width * 2 + wvg_width 
        sim_length = bnd_width * 2
        
        # Define different waveguide radii to test
        wvg_radii = [5]  # um

        # Create figure with two subplots side by side
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))

        for wvg_radius in wvg_radii:
                # Define the vertices of the annular (ring) waveguide
                vertices = []
                radius_out = wvg_radius + wvg_width / 2
                radius_in = wvg_radius - wvg_width / 2
                
                # Outer circle vertices (counterclockwise)
                for idp in range(n_circle_vertex + 1):
                        angle = idp / n_circle_vertex * 2 * np.pi
                        vertices.append(mp.Vector3(radius_out * np.cos(angle), 
                                                radius_out * np.sin(angle)))
                
                # Inner circle vertices (clockwise to close the polygon)
                for idp in range(n_circle_vertex, -1, -1):
                        angle = idp / n_circle_vertex * 2 * np.pi
                        vertices.append(mp.Vector3(radius_in * np.cos(angle), 
                                                radius_in * np.sin(angle)))
                
                # Transform the vertices into a material grid
                semi_axis = wvg_radius + bnd_width
                material_grid = SL.polygon_to_materialgrid(
                vertices=vertices,
                sub_resolution=sub_pixel,
                medium_outside=mp.Medium(epsilon=cld_neff**2),
                medium_inside=mp.Medium(epsilon=wvg_neff**2),
                x_axis=[-semi_axis, semi_axis],
                y_axis=[-semi_axis, semi_axis])

                # Geometry definition
                geometry = [mp.Block(
                size=mp.Vector3(semi_axis * 2, semi_axis * 2, 0),
                center=mp.Vector3(),
                material=material_grid)]
                
                # Calculate simulation domain boundaries
                cell_size, cell_center = SL.compute_geometry_bounds(geometry)
                
                # Create phase-matched sources for TM mode (Ez with Hy)
                sources = [
                mp.Source(
                        mp.GaussianSource(frequency=frq, fwidth=frq/2), 
                        component=mp.Ez, 
                        center=mp.Vector3(wvg_radius, 0),
                        size=mp.Vector3(wvg_width))]  
                
                pml_thickness = 1.0
                pml_layers = [mp.PML(pml_thickness)]

                # Initialize simulation
                sim = mp.Simulation(
                cell_size=cell_size,
                sources=sources,
                geometry=geometry,
                resolution=sim_resolution,
                boundary_layers=pml_layers)
                
                # Define DFT monitoring region for field extraction
                dft_volume = mp.Volume(
                center=mp.Vector3(-wvg_radius),
                size=mp.Vector3(bnd_width * 2, cell_size.y))
                
                dft = sim.add_dft_fields([mp.Ez, mp.Hx], [frq], where=dft_volume)
                
                # Run simulation for sufficient time for wave to propagate
                sim.run(until=wvg_radius * 2 * np.pi * wvg_neff)

                # Extract permittivity distribution over full simulation domain
                eps_data = sim.get_array(
                        center=mp.Vector3(0, 0, 0),
                        size=cell_size,
                        component=mp.Dielectric)
                
                # Extract electromagnetic fields from DFT monitors
                Ez = sim.get_dft_array(dft, mp.Ez, 0)
                Hx = sim.get_dft_array(dft, mp.Hx, 0)

                # Extract cross-sectional profiles at the center y-position
                y_center_index = int(semi_axis * sim_resolution)
                Ez_profile = Ez[:, y_center_index]
                Hx_profile = Hx[:, y_center_index]
                center_position = np.argmax(np.abs(Ez_profile))
                angle = np.angle(Ez_profile[center_position])
                Ez_profile *= np.exp(-1j*angle)
                Hx_profile *= -np.exp(-1j*(angle+np.pi/2))
                
                # Extract corresponding permittivity profile
                x_index = int((dft_volume.center.x + dft_volume.size.x / 2 + cell_size.x / 2) * sim_resolution)
                eps_profile = eps_data[:x_index+1, y_center_index]
                
                # Spatial discretization step
                dx = dft_volume.size.x / len(Ez_profile)
                
                # Normalize mode fields (reshape to 2D as expected by function)
                Ez_normalize, Hx_normalize, neff = SL.normalizing_mode_field(
                        Ez=Ez_profile.reshape(1, -1), 
                        Hy=Hx_profile.reshape(1, -1),
                        dx=dx, eps_cross=eps_profile)
                
                # Plot normalized field profile
                cross_axis = np.linspace(-bnd_width/2, bnd_width/2, len(Ez_normalize))
                ax1.plot(Ez_normalize, label=f'Ez r={wvg_radius}μm, neff={neff:.3f}', linewidth=2)
                ax1.plot(Hx_normalize, label=f'Hx r={wvg_radius}μm, neff={neff:.3f}', linewidth=2)
        
        # Loop through different waveguide widths
        for wvg_radius in wvg_radii:
                
                # Create the material 
                Nx = int(sim_length * sim_resolution * sub_pixel)
                Ny = int(sim_width * sim_resolution * sub_pixel)
                weights = np.zeros((Nx, Ny))
                for i in range(Nx):
                        for j in range(Ny):
                                y = (j - Ny/2) / sim_resolution / sub_pixel

                                # Chose neff depending on y position
                                if abs(y) <= wvg_width/2:
                                        n = wvg_neff
                                else:
                                        n = cld_neff

                                # Correct refractive index per radius
                                weights[i, j] = (n * (1 + y/np.sqrt(2)/wvg_radius))**2

                # Create the material from the grid
                max_weight = np.max(weights)
                weights3d = weights[:, :, None] / max_weight
                material_grid = mp.MaterialGrid(
                                mp.Vector3(Nx, Ny, 1),
                                medium1=mp.Medium(epsilon=0),
                                medium2=mp.Medium(epsilon=max_weight),
                                weights=weights3d)
                
                # Assign the material to a block 
                geometry = [mp.Block(
                        size=mp.Vector3(sim_length, sim_width, 0),
                        center=mp.Vector3(),
                        material=material_grid)]

                # Find the Mode based on the geometry
                Ez1_cross, Hy1_cross, neff = SL.finding_mode_from_geometry(geometry, 
                                                                        frequency=frq,
                                                                        mode=1,
                                                                        resolution=sim_resolution)
        
                # Define axis of the mode
                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross))
        
                # Plotting with different colors/styles for each width
                ax2.plot(cross_axis, Ez1_cross, 
                         label=f'r={wvg_radius}μm, neff={neff:.3f}', 
                         linewidth=2)
                ax2.plot(cross_axis, Hy1_cross, 
                         label=f'r={wvg_radius}μm, neff={neff:.3f}', 
                         linewidth=2)

        # Configure axes
        plt_fontsize = 16
        ax1.set_title('Ez Mode Profile', fontsize=plt_fontsize, fontweight='bold')
        ax1.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax1.set_ylabel('Normalized Field', fontsize=plt_fontsize)
        ax2.tick_params(axis='both', which='major', labelsize=plt_fontsize)
        ax1.grid(True)
        ax1.legend(fontsize=plt_fontsize-2, loc='best')

        # Configure subplot with larger fonts
        ax2.set_title('Ez Mode Profile', fontsize=plt_fontsize, fontweight='bold')
        ax2.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax2.set_ylabel('Normalized Field', fontsize=plt_fontsize)
        ax2.legend(fontsize=plt_fontsize, loc='best')
        ax2.grid(True)
        ax2.tick_params(axis='both', which='major', labelsize=plt_fontsize)
    
        # Show the plot
        plt.show()
        