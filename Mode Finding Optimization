from matplotlib.widgets import Button
import matplotlib.pyplot as plt
import SimLibrary as SL
import numpy as np
import meep as mp
import json 

width_found = True
mode_calculated_kind = 'none' # Chose one between 'none', 'wvg', 'fiber'
mode_calculated = (mode_calculated_kind == 'none')
propagation_waveguide = True
propagation_coupler = True
propagation_mmi = True
propagation_taper = False
propagation_ring = False

#################################################################
###  1 - Find waveguide width for single mode in wanted range ###
#################################################################
# If we need to determine the mode in the wavelength of interest
if not width_found:
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm
        wvl_n = 2
        wvl_simulated = np.linspace(wvl_min, wvl_max, wvl_n)
        frq_simulated = 1000 / wvl_simulated
        
        # Geometry parameters
        sim_length = 5
        sim_width = 5
        sim_resolution = 40
        wvg_neff = 3
        cld_neff = 1.3
        
        # Define different waveguide widths to test
        wvg_widths = [0.4, 0.35, 0.3, 0.25, 0.2]  # You can modify this list
        
        # Create figure with two subplots side by side
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))
    
        # Loop through both wavelengths
        for wvl_idx, frq in enumerate(frq_simulated):
                # Select the appropriate subplot
                ax = ax1 if wvl_idx == 0 else ax2
                
                # Loop through different waveguide widths
                for wvg_width in wvg_widths:
                        geometry = [
                        mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                                center=mp.Vector3(),
                                material=mp.Medium(epsilon=cld_neff**2)),
                        mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                                center=mp.Vector3(),
                                material=mp.Medium(epsilon=wvg_neff**2))]
            
                # Mode found
                Ez1_cross, Hy1_cross, neff = SL.finding_mode_from_geometry(geometry, 
                                                                           frequency=frq,
                                                                           mode=2,
                                                                           resolution=sim_resolution)
            
                # Define axis of the mode
                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross))
            
                # Plotting with different colors/styles for each width
                ax.plot(cross_axis, Ez1_cross, 
                        label=f'w={wvg_width}μm, neff={neff:.3f}', 
                        linewidth=2)
        
        # Configure subplot with larger fonts
        plt_fontsize = 16
        ax.set_title(f'Ez Mode Profile', fontsize=plt_fontsize, fontweight='bold')
        ax.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax.set_ylabel('Normalized Field', fontsize=plt_fontsize)
        ax.legend(fontsize=plt_fontsize, loc='best')
        ax.grid(True, alpha=0.3)
        ax.tick_params(axis='both', which='major', labelsize=plt_fontsize)
    
        # Show the plot
        plt.show()

#################################################################
###  2 - Find waveguide modes for all wavelengths of interest ###
#################################################################
if not mode_calculated:
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm 
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Geometry parameters
        sim_length = 5
        sim_width = 5 if mode_calculated == 'wvg' else 20
        sim_resolution = 40
        wvg_neff = 3 if mode_calculated == 'wvg' else 1.46
        cld_neff = 1.3 if mode_calculated == 'wvg' else 1.44

        # Define fixed waveguide width
        wvg_width = 0.3 if mode_calculated == 'wvg' else 4.5

        # Create single figure
        fig, ax = plt.subplots(1, 1, figsize=(12, 8))

        # Loop through all frequencies
        for frq_idx, frq in enumerate(frq_simulated):
                geometry = [
                mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=cld_neff**2)),
                mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=wvg_neff**2))]

                # Mode found
                Ez1_cross, Hy1_cross, neff = SL.finding_mode_from_geometry(geometry, 
                                                                        frequency=frq,
                                                                        mode=1,
                                                                        resolution=sim_resolution)

                # Define axis of the mode
                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross))

                # Plotting with different colors for each wavelength
                ax.plot(cross_axis, Ez1_cross, 
                        label=f'f={frq:.3f}nm, neff={neff:.3f}', 
                        linewidth=2)

                # Saving individual data files for each wavelength
                data = {
                "Ez": Ez1_cross.tolist(),
                "Hy": Hy1_cross.tolist(),
                "neff": float(neff),
                "cross_axis": cross_axis.tolist(),
                "wvg_width": float(wvg_width),
                "frequency": float(frq)
                }

                # Save individual file
                file_name_wvg = f"Output/Mode_ex_width{wvg_width}_frequency{frq:.3f}nm.json"
                file_name_fiber = f"Output/Mode_ex_fiber_frequency{frq:.3f}nm.json"
                with open(file_name_wvg if mode_calculated == 'wvg' else file_name_fiber, "w") as f:
                        json.dump(data, f)

                # Configure plot with larger fonts
                plt_fontsize = 16
                title_name_wvg = f"Ez Mode Profile for Width={wvg_width}μm at Different Wavelengths"
                title_name_fiber = f"Ez Mode Profile for Fiber at Different Wavelengths"
                ax.set_title(title_name_wvg if mode_calculated == 'wvg' else title_name_fiber, 
                        fontsize=plt_fontsize, fontweight='bold')
                ax.set_xlabel('Position [μm]', fontsize=plt_fontsize)
                ax.set_ylabel('Normalized Field', fontsize=plt_fontsize)
                ax.legend(fontsize=plt_fontsize, loc='best')  
                ax.grid(True, alpha=0.3)
                ax.tick_params(axis='both', which='major', labelsize=plt_fontsize)

        # Show the plot
        plt.show()

#################################################################
###  3 - Propagate waveguide and calculate overlap with mode  ###
#################################################################
if not propagation_waveguide:
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm 
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Geometry parameters
        sim_length = 50
        sim_width = 5
        sim_resolution = 20
        pml_thickness = 1
        wvg_neff = 3
        cld_neff = 1.3

        # Define fixed waveguide width
        wvg_width = 0.3 

        # Create the geometry
        geometry = [
                mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=cld_neff**2)),
                mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=wvg_neff**2))]
        
        # Calculate the cell size and position
        cell_size, cell_center = SL.compute_geometry_bounds(geometry)

        # Boundary condition
        pml_layers = [mp.PML(pml_thickness)]
        
        # Create the sources joining all the frequencies
        sources = []
        Ez1_cross_array = []
        Hy1_cross_array = []
        for frq in frq_simulated:
                # Load mode from previous calculated one
                with open(f"Output/Mode_ex_width{wvg_width}_frequency{frq:.3f}nm.json", "r") as f:
                        data = json.load(f)
                        Ez1_cross = np.array(data["Ez"])
                        Hy1_cross = np.array(data["Hy"])
                        neff = data["neff"]
                        cross_axis = np.array(data["cross_axis"])

                        # Append to array
                        Ez1_cross_array.append(Ez1_cross)
                        Hy1_cross_array.append(Hy1_cross)

                # Create a source from the mode fields
                source = SL.generate_modal_source(Ez_cross = Ez1_cross,
                                                Hy_cross = Hy1_cross,
                                                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross)),
                                                src_position = mp.Vector3(-sim_length / 2 + pml_thickness, 0),
                                                src_size=mp.Vector3(0, sim_width),
                                                frequency=frq)
                
                sources.append(source[0])
                sources.append(source[1])

        # Simulation settings
        sim = mp.Simulation(
                cell_size=cell_size,
                sources=sources,
                geometry=geometry,
                resolution=sim_resolution,
                boundary_layers=pml_layers
        )

        # Define DFT fields to be recorded
        dft = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, 
                                                where=mp.Volume(center=mp.Vector3(),
                                                size=cell_size))

        # Run the simulation
        sim.run(until=sim_length*wvg_neff*2)
        
        # Visualize the geometry simulated
        eps_data = sim.get_array(center=mp.Vector3(0, 0, 0), 
                                size=cell_size, 
                                component=mp.Dielectric)

        # Create figure with two subplots
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
        
        # LEFT SUBPLOT - Field Propagation Visualization
        # Plot the material structure
        ax1.imshow(eps_data.transpose(), interpolation='spline36', 
                   cmap='binary', aspect='auto', extent=(0, sim_length, 0, sim_width))
        overlap_axis = np.linspace(-sim_length/2, sim_length/2, len(eps_data))

        # Extract the fields at the DFT region and compute overlaps
        for idx, frq in enumerate(frq_simulated):
                ez_data = sim.get_dft_array(dft, mp.Ez, idx)
                hy_data = sim.get_dft_array(dft, mp.Hy, idx)
                
                # Overlay field on the left subplot (using transparency to show all)
                ax1.imshow(np.abs(ez_data).transpose(), interpolation='spline36', 
                        cmap='RdBu', alpha=1/wvl_n, aspect='auto', 
                        extent=(0, sim_length, 0, sim_width))
                
                # Create field axis for the cross section
                field_axis = np.linspace(-sim_width/2, sim_width/2, len(ez_data[0]))
                
                # Calculate overlap
                overlap = SL.calculate_modal_overlap(Ez_cross = Ez1_cross_array[idx], 
                                                Hy_cross = Hy1_cross_array[idx], 
                                                Ez_field = ez_data, 
                                                Hy_field = hy_data,
                                                cross_axis = cross_axis,
                                                field_axis = field_axis)
                
                # Add overlap to the plot
                ax2.plot(overlap_axis, overlap, label=f"frq {frq:.3f} THz/c")
                
        # Configure left subplot
        plt_fontsize = 16
        ax1.set_title('Field Propagation (Ez)', fontsize=plt_fontsize, fontweight='bold')
        ax1.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax1.set_ylabel('Width [μm]', fontsize=plt_fontsize)
        ax1.axis('off')
        
        # Add scale bar or position markers
        ax1.axvline(x=pml_thickness, color='white', linestyle='--', alpha=0.5, linewidth=1)
        ax1.axvline(x=sim_length-pml_thickness, color='white', linestyle='--', alpha=0.5, linewidth=1)
        ax1.text(x=-3*pml_thickness+sim_length, y=4, s='PML', color='white', fontsize=plt_fontsize, rotation=90)
        
        # RIGHT SUBPLOT - Overlap
        ax2.set_xlabel('Distance [μm]', fontsize=plt_fontsize)
        ax2.set_ylabel('Modal Overlap', fontsize=plt_fontsize)
        ax2.set_title('Modal Overlap vs Wavelength', fontsize=plt_fontsize, fontweight='bold')
        ax2.grid(True, alpha=0.3)
        ax2.legend()
        
        # Overall title
        fig.suptitle(f'Waveguide Propagation Analysis (Width = {wvg_width}μm)', 
                        fontsize=16, fontweight='bold')
        
        plt.show()


#################################################################
###  4 - Propagate light in a coupler to see its overlap      ###
#################################################################
if not propagation_coupler:
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm 
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Geometry parameters
        sim_length = 50
        sim_width = 5
        sim_resolution = 20
        pml_thickness = 1
        wvg_neff = 3
        cld_neff = 1.3

        # Define fixed waveguide width
        wvg_width = 0.3 
        coupler_gap = 0.3

        # Create the geometry
        geometry = [
                mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                        center=mp.Vector3(),
                        material=mp.Medium(epsilon=cld_neff**2)),
                mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                        center=mp.Vector3(0, coupler_gap/2+wvg_width/2),
                        material=mp.Medium(epsilon=wvg_neff**2)),
                mp.Block(size=mp.Vector3(sim_length, wvg_width, 0),
                        center=mp.Vector3(0, -coupler_gap/2-wvg_width/2),
                        material=mp.Medium(epsilon=wvg_neff**2))]

        # Calculate the cell size and position
        cell_size, cell_center = SL.compute_geometry_bounds(geometry)

        # Boundary condition
        pml_layers = [mp.PML(pml_thickness)]

        # Create the sources joining all the frequencies
        sources = []
        Ez1_cross_array = []
        Hy1_cross_array = []
        for frq in frq_simulated:
                # Load mode from previous calculated one
                with open(f"Output/Mode_ex_width{wvg_width}_frequency{frq:.3f}nm.json", "r") as f:
                        data = json.load(f)
                        Ez1_cross = np.array(data["Ez"])
                        Hy1_cross = np.array(data["Hy"])
                        neff = data["neff"]
                        cross_axis = np.array(data["cross_axis"])

                # Append to array
                Ez1_cross_array.append(Ez1_cross)
                Hy1_cross_array.append(Hy1_cross)

                # Create a source from the mode fields
                source = SL.generate_modal_source(Ez_cross = Ez1_cross,
                                                Hy_cross = Hy1_cross,
                                                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross)),
                                                src_position = mp.Vector3(-sim_length / 2 + pml_thickness, coupler_gap/2+wvg_width/2),
                                                src_size=mp.Vector3(0, sim_width),
                                                frequency=frq)

                sources.append(source[0])
                sources.append(source[1])

        # Simulation settings
        sim = mp.Simulation(
                cell_size=cell_size,
                sources=sources,
                geometry=geometry,
                resolution=sim_resolution,
                boundary_layers=pml_layers)

        # Define DFT fields to be recorded
        dft = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, 
                                        where=mp.Volume(center=mp.Vector3(),
                                        size=cell_size))

        # Run the simulation
        sim.run(until=sim_length*wvg_neff*2)

        # Visualize the geometry simulated
        eps_data = sim.get_array(center=mp.Vector3(0, 0, 0), 
                                size=cell_size, 
                                component=mp.Dielectric)

        # Create figure with two subplots
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

        # LEFT SUBPLOT - Field Propagation Visualization
        # Plot the material structure
        ax1.imshow(eps_data.transpose(), interpolation='spline36', cmap='binary', aspect='auto',
                   extent=(0, sim_length, 0, sim_width))
        overlap_axis = np.linspace(0, sim_length, len(eps_data))

        # Extract the fields at the DFT region and compute overlaps
        for idx, frq in enumerate(frq_simulated):
                ez_data = sim.get_dft_array(dft, mp.Ez, idx)
                hy_data = sim.get_dft_array(dft, mp.Hy, idx)

                # Overlay field on the left subplot (using transparency to show all)
                ax1.imshow(np.abs(ez_data).transpose(), interpolation='spline36', 
                                cmap='RdBu', alpha=0.1, aspect='auto',
                                extent=(0, sim_length, 0, sim_width))

                # Create field axis for the cross section
                field_axis = np.linspace(-sim_width/2, sim_width/2, len(ez_data[0]))

                # Calculate overlap
                overlap = SL.calculate_modal_overlap(Ez_cross = Ez1_cross_array[idx], 
                                                Hy_cross = Hy1_cross_array[idx], 
                                                Ez_field = ez_data, 
                                                Hy_field = hy_data,
                                                cross_axis = cross_axis + coupler_gap / 2 + wvg_width / 2,
                                                field_axis = field_axis)

                # Add overlap to the plot
                ax2.plot(overlap_axis, overlap, label=f"frq {frq:.3f} nm")

        # Configure left subplot
        plt_fontsize = 16
        ax1.set_title('Field Propagation (Ez)', fontsize=plt_fontsize, fontweight='bold')
        ax1.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax1.set_ylabel('Width [μm]', fontsize=plt_fontsize)
        ax1.axis('off')

        # Add scale bar or position markers
        ax1.axvline(x=pml_thickness, color='white', linestyle='--', alpha=0.5, linewidth=1)
        ax1.axvline(x=sim_length-pml_thickness, color='white', linestyle='--', alpha=0.5, linewidth=1)
        ax1.text(x=-3*pml_thickness+sim_length, y=4, s='PML', color='white', fontsize=plt_fontsize, rotation=90)

        # RIGHT SUBPLOT - Overlap
        ax2.set_xlabel('Distance [μm]', fontsize=plt_fontsize)
        ax2.set_ylabel('Modal Overlap', fontsize=plt_fontsize)
        ax2.set_title('Modal Overlap vs Wavelength', fontsize=plt_fontsize, fontweight='bold')
        ax2.tick_params(axis='x', labelsize=plt_fontsize)
        ax2.tick_params(axis='y', labelsize=plt_fontsize)
        ax2.grid(True, alpha=0.3)
        ax2.legend()

        # Overall title
        fig.suptitle(f'Waveguide Propagation Analysis (Width = {wvg_width}μm)', 
                fontsize=16, fontweight='bold')

        plt.show()

#################################################################
###  5 - Propagate light in a MMI to see its overlap          ###
#################################################################
if not propagation_mmi:
        # Define mmi length to simulate
        mmi_lengths = [40, 14.5, 14.75, 15, 15.25, 15.5]   #(μm)

        # Fixed spectral parameters
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm
        wvl_n = 8
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Fixed simulation/global parameters
        sim_width = 6
        sim_resolution = 30
        pml_thickness = 1
        wvg_neff = 3
        cld_neff = 1.3
        mmi_width = 4
        wvg_width = 0.3
        mmi_output_shift = mmi_width / 4

        # Boundary condition
        pml_layers = [mp.PML(pml_thickness)]

        # Perform the same operation on different mmi_lengths
        results = []
        for mmi_length in mmi_lengths:
                # Adjust length to have enough space for waveguide
                sim_length = mmi_length + 25
                wvg_length = (sim_length - mmi_length) / 2

                # Geometry
                geometry = [
                        mp.Block(size=mp.Vector3(sim_length, sim_width, 0),
                                center=mp.Vector3(),
                                material=mp.Medium(epsilon=cld_neff**2)),

                        mp.Block(size=mp.Vector3(wvg_length, wvg_width, 0),
                                center=mp.Vector3(-sim_length/2 + wvg_length/2),
                                material=mp.Medium(epsilon=wvg_neff**2)),

                        mp.Block(size=mp.Vector3(mmi_length, mmi_width, 0),
                                center=mp.Vector3(),
                                material=mp.Medium(epsilon=wvg_neff**2)),

                        mp.Block(size=mp.Vector3(wvg_length, wvg_width, 0),
                                center=mp.Vector3(sim_length/2 - wvg_length/2,  mmi_output_shift),
                                material=mp.Medium(epsilon=wvg_neff**2)),

                        mp.Block(size=mp.Vector3(wvg_length, wvg_width, 0),
                                center=mp.Vector3(sim_length/2 - wvg_length/2, -mmi_output_shift),
                                material=mp.Medium(epsilon=wvg_neff**2)),
                ]
                
                # Compute the geometry boundary
                cell_size, cell_center = SL.compute_geometry_bounds(geometry)

                # Load mode fields & build sources (per frequency)
                Ez1_cross_array = []
                Hy1_cross_array = []
                sources = []

                for frq in frq_simulated:
                        # Load the file
                        with open(f"Output/Mode_ex_width{wvg_width}_frequency{frq:.3f}nm.json", "r") as f:
                                data = json.load(f)
                                
                                # Extract the files
                                Ez1_cross = np.array(data["Ez"])
                                Hy1_cross = np.array(data["Hy"])
                                Ez1_cross_array.append(Ez1_cross)
                                Hy1_cross_array.append(Hy1_cross)
                                
                                # Create the source of the simulation
                                source = SL.generate_modal_source(
                                        Ez_cross=Ez1_cross,
                                        Hy_cross=Hy1_cross,
                                        cross_axis=np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross)),
                                        src_position=mp.Vector3(-sim_length/2 + pml_thickness),
                                        src_size=mp.Vector3(0, sim_width),
                                        frequency=frq)

                                sources.append(source[0])
                                sources.append(source[1])
                
                # Fixed Simulation settings
                sim = mp.Simulation(
                cell_size=cell_size,
                sources=sources,
                geometry=geometry,
                resolution=sim_resolution,
                boundary_layers=pml_layers)

                # Times
                t_overlap = wvg_length * wvg_neff * 1.2
                t_total   = sim_length * wvg_neff * 2.0

                # Volumes
                vol_input = mp.Volume(
                        center=mp.Vector3(-sim_length/2 + wvg_length/2, 0),
                        size=mp.Vector3(wvg_length, sim_width, 0))

                vol_total = mp.Volume(
                        center=mp.Vector3(wvg_length/2),
                        size=mp.Vector3(sim_length-wvg_length, sim_width, 0))

                # Stage 1 DFT
                dft_in = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, where=vol_input)
                sim.run(until=t_overlap)

                Ez_in_list = [sim.get_dft_array(dft_in, mp.Ez, i) for i in range(wvl_n)]
                Hy_in_list = [sim.get_dft_array(dft_in, mp.Hy, i) for i in range(wvl_n)]

                # Stage 2 DFT
                dft_out = sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, where=vol_total)
                sim.run(until=t_total)
                Ez_out_list = [sim.get_dft_array(dft_out, mp.Ez, i) for i in range(wvl_n)]
                Hy_out_list = [sim.get_dft_array(dft_out, mp.Hy, i) for i in range(wvl_n)]

                # Material for plotting
                eps_data = sim.get_array(center=mp.Vector3(0, 0, 0),
                                        size=cell_size,
                                        component=mp.Dielectric)

                # Axes/discretization (recomputed because wvg_length depends on mmi_length)
                n_points_input_wvg  = int(round(wvg_length * sim_resolution))
                n_points_mmi        = int(round(mmi_length * sim_resolution))
                n_points_output_wvg = int(round(wvg_length * sim_resolution))
                total_points        = n_points_input_wvg + n_points_mmi + n_points_output_wvg

                overlap_axis = np.linspace(0, sim_length, total_points)
                field_axis = np.linspace(-sim_width/2, sim_width/2, sim_width * sim_resolution)
                cross_axis = np.linspace(-sim_width/2, sim_width/2, len(Ez1_cross))

                # Compute overlaps for each frequency (store final curves)
                overlap_totals = []
                Ez_list = []
                for idx in range(wvl_n):
                        # Extract the field calculated
                        Ez_in  = Ez_in_list[idx]
                        Hy_in  = Hy_in_list[idx]
                        Ez_out = Ez_out_list[idx]
                        Hy_out = Hy_out_list[idx]
                        Ez = np.concatenate([Ez_in, Ez_out], axis=0)
                        Ez_list.append(Ez)
                        
                        # Initialize the overlap
                        overlap_total = np.zeros(total_points)

                        # Calculate the overlap at the input
                        overlap_in = SL.calculate_modal_overlap(
                                Ez_cross=Ez1_cross_array[idx],
                                Hy_cross=Hy1_cross_array[idx],
                                Ez_field=Ez_in,
                                Hy_field=Hy_in,
                                cross_axis=cross_axis,
                                field_axis=field_axis)
                        overlap_total[:n_points_input_wvg] = overlap_in[:n_points_input_wvg]
                        
                        # The overlap at the MMI is set to 0 since does not make sense
                        overlap_total[n_points_input_wvg:n_points_input_wvg + n_points_mmi] = 0

                        # Calculate the overlap a
                        overlap_out = SL.calculate_modal_overlap(
                                Ez_cross=Ez1_cross_array[idx],
                                Hy_cross=Hy1_cross_array[idx],
                                Ez_field=Ez_out,
                                Hy_field=Hy_out,
                                cross_axis=cross_axis + mmi_output_shift,
                                field_axis=field_axis)
                        
                        overlap_total[(len(overlap_total)-len(overlap_out[n_points_mmi:])):] = overlap_out[n_points_mmi:]
                        overlap_totals.append(overlap_total)

                # Build a single overlay image (so we can update one artist instead of stacking many)
                Ez_overlay = np.sum([np.abs(Ez) for Ez in Ez_list], axis=0)

                results.append({
                        "mmi_length": mmi_length,
                        "wvg_length": wvg_length,
                        "eps_data": eps_data,
                        "Ez_overlay": Ez_overlay,
                        "overlap_axis": overlap_axis,
                        "overlap_totals": overlap_totals,  
                        "field_axis": field_axis})

        # Initialize the plot
        plt_fontsize = 16
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
        
        # Initialize the state of the plot
        state = {"k": 0} 

        # Initialize with first result
        r0 = results[0]
        
        # Create the first image (material + field)
        eps_im = ax1.imshow(r0["eps_data"].transpose(),
                        interpolation='spline36', cmap='binary', aspect='auto',
                        extent=(0, sim_length, 0, sim_width))

        field_im = ax1.imshow(r0["Ez_overlay"].transpose(),
                        interpolation='spline36', cmap='RdBu',
                        aspect='auto', alpha=1,
                        extent=(0, sim_length, 0, sim_width))

        # Setting of first axis
        ax1.set_title('Geometry', fontsize=plt_fontsize, fontweight='bold')
        ax1.set_xlabel('Position [μm]', fontsize=plt_fontsize)
        ax1.set_ylabel('Width [μm]', fontsize=plt_fontsize)
        ax1.axis('off')

        # Plot of the second axis
        lines = []
        for idx, frq in enumerate(frq_simulated):
                (ln,) = ax2.plot(r0["overlap_axis"], r0["overlap_totals"][idx],
                                label=f"{frq:.3f} Thz/c")
                lines.append(ln)
        
        # Setting of the second axis
        vline1 = ax2.axvline(x=r0["wvg_length"], color='gray', linestyle='--', alpha=0.5, linewidth=1)
        vline2 = ax2.axvline(x=r0["wvg_length"] + r0["mmi_length"], color='gray', linestyle='--', alpha=0.5, linewidth=1)
        ax2.set_xlabel('Distance [μm]', fontsize=plt_fontsize)
        ax2.set_ylabel('Modal Overlap', fontsize=plt_fontsize)
        ax2.set_title('Modal Overlap (2-stage run)', fontsize=plt_fontsize, fontweight='bold')
        ax2.tick_params(axis='both', which='major', labelsize=plt_fontsize)
        ax2.grid(True, alpha=0.3)
        ax2.legend()
        ax2.set_ylim(-0.1, 1.1) 

        fig.suptitle(f'Waveguide Propagation Analysis (Width = {wvg_width} μm) | MMI length = {r0["mmi_length"]} μm',
                fontsize=16, fontweight='bold')

        # Create a function to change resulting plot
        def update_plot(k):
                # Take results 
                r = results[k]

                # Recreate the image
                eps_im.set_data(r["eps_data"].transpose())
                field_im.set_data(r["Ez_overlay"].transpose())

                # Recreate the overlap
                for i, ln in enumerate(lines):
                        ln.set_data(r["overlap_axis"], r["overlap_totals"][i])
                vline1.set_xdata([r["wvg_length"], r["wvg_length"]])
                vline2.set_xdata([r["wvg_length"] + r["mmi_length"], r["wvg_length"] + r["mmi_length"]])

                # Redraw and change settings
                ax2.relim()
                ax2.autoscale_view()
                fig.suptitle(f'Waveguide Propagation Analysis (Width = {wvg_width} μm) | MMI length = {r["mmi_length"]} μm',
                                fontsize=16, fontweight='bold')
                fig.canvas.draw_idle()

        # Right button
        btn_ax_right = fig.add_axes([0.92, 0.475, 0.06, 0.08])
        btn_right = Button(btn_ax_right, "", color="white", hovercolor="0.9")

        # Left button (slightly outside)
        btn_ax_left = fig.add_axes([0.02, 0.475, 0.06, 0.08])
        btn_left = Button(btn_ax_left, "", color="white", hovercolor="0.9")

        # Right-pointing triangle
        tri_right = plt.Polygon(
                [[0.30, 0.20], [0.30, 0.80], [0.75, 0.50]],
                closed=True,
                transform=btn_ax_right.transAxes,
                facecolor="black",
                edgecolor="black")
        btn_ax_right.add_patch(tri_right)

        # Left-pointing triangle (mirrored)
        tri_left = plt.Polygon(
                [[0.70, 0.20], [0.70, 0.80], [0.25, 0.50]],
                closed=True,
                transform=btn_ax_left.transAxes,
                facecolor="black",
                edgecolor="black")
        btn_ax_left.add_patch(tri_left)

        # Clean button axes
        for ax in (btn_ax_right, btn_ax_left):
                _ = ax.set_xticks([])
                _ = ax.set_yticks([])
        for spine in ax.spines.values():
                spine.set_visible(False)

        # Callbacks
        def on_button_right(event):
                state["k"] = (state["k"] + 1) % len(results)
                update_plot(state["k"])

        def on_button_left(event):
                state["k"] = (state["k"] - 1) % len(results)
                update_plot(state["k"])

        _ = btn_right.on_clicked(on_button_right)
        _ = btn_left.on_clicked(on_button_left)

        plt.show()
        
#################################################################
###  6 - Propagate light in a subresolution taper             ###
#################################################################
if not propagation_taper:
        # Fixed spectral parameters
        wvl_min = 1530 # nm
        wvl_max = 1565 # nm
        wvl_n = 1
        frq_simulated = np.linspace(1000 / wvl_max, 1000 / wvl_min, wvl_n)

        # Fixed simulation parameters for waveguide
        wvg_width_start = 0.3
        wvg_width_end = 1.5
        taper_length = 30
        wvg_strt_length = 20
        wvg_neff = 3
        cld_neff = 1.3

        # Fixed simulation parameters for fiber
        fiber_distance = 0.5
        fiber_length = 20
        fiber_core_width = 4.5
        fiber_core_neff = 1.46
        fiber_cld_neff = 1.44

        # Fixed simulation parameters for simulation
        sim_width = 5
        sim_length = taper_length + 2*wvg_strt_length + fiber_distance + fiber_length
        sim_resolution = 20
        pml_thickness = 1

        # Boundary condition
        pml_layers = [mp.PML(pml_thickness)]

        # Define the taper vertices
        vertices = [mp.Vector3(0, -wvg_width_start/2),
                    mp.Vector3(wvg_strt_length, -wvg_width_start/2),
                    mp.Vector3(wvg_strt_length+taper_length, -wvg_width_end/2),
                    mp.Vector3(2*wvg_strt_length+taper_length, -wvg_width_end/2),
                    mp.Vector3(2*wvg_strt_length+taper_length, wvg_width_end/2),
                    mp.Vector3(wvg_strt_length+taper_length, wvg_width_end/2),
                    mp.Vector3(wvg_strt_length, wvg_width_start/2),
                    mp.Vector3(0, wvg_width_start/2)]
        
        # Transform the vertices in a material grid
        material_grid = SL.polygon_to_materialgrid(vertices=vertices,
                                                   medium_outside=mp.Medium(epsilon=cld_neff**2),
                                                   medium_inside=mp.Medium(epsilon=wvg_neff**2),
                                                   y_axis = [-sim_width/2, sim_width/2])
        
        # Geometry definition
        geometry = [mp.Block(size=mp.Vector3(sim_length-fiber_distance-fiber_length, sim_width, 0),
                             center=mp.Vector3(-fiber_distance/2-fiber_length/2),
                             material=material_grid),
                   
                    # Air
                    mp.Block(size=mp.Vector3(fiber_length+fiber_distance, sim_width, 0),
                             center=mp.Vector3(-sim_length/2+2*wvg_strt_length+taper_length+fiber_distance/2+fiber_length/2),
                             material=mp.Medium(epsilon=1)),

                    # Fiber
                    mp.Block(size=mp.Vector3(fiber_length, sim_width, 0),
                             center=mp.Vector3(-sim_length/2+2*wvg_strt_length+taper_length+fiber_distance+fiber_length/2),
                             material=mp.Medium(epsilon=fiber_cld_neff**2)),
                    mp.Block(size=mp.Vector3(fiber_length, fiber_core_width, 0),
                            center=mp.Vector3(-sim_length/2+2*wvg_strt_length+taper_length+fiber_distance+fiber_length/2),
                            material=mp.Medium(epsilon=fiber_core_neff**2))]
        
        # Compute the geometry boundary
        cell_size, cell_center = SL.compute_geometry_bounds(geometry)

        # Load mode fields & build sources (per frequency)
        Ez1_fiber_array = []
        Hy1_fiber_array = []
        mode_sources = []

        for frq in frq_simulated:
                # Load the file for creating mode in input
                with open(f"Output/Mode_ex_width{wvg_width_start}_frequency{frq:.3f}nm.json", "r") as f:
                        data = json.load(f)
                        
                        # Extract the files
                        Ez1_cross = np.array(data["Ez"])
                        Hy1_cross = np.array(data["Hy"])
                        mode_cross_axis = np.array(data['cross_axis'])

                        # Create the source of the simulation
                        source = SL.generate_modal_source(
                                Ez_cross=Ez1_cross,
                                Hy_cross=Hy1_cross,
                                cross_axis=mode_cross_axis,
                                src_position=mp.Vector3(-sim_length/2 + pml_thickness),
                                src_size=mp.Vector3(0, sim_width),
                                frequency=frq)

                        mode_sources.append(source[0])
                        mode_sources.append(source[1])

                        Ez1_fiber_array.append(Ez1_cross)
                        Hy1_fiber_array.append(Hy1_cross)
                        fiber_cross_axis = np.array(data['cross_axis'])

                """   
                # Load the file to calculate fiber overlap
                with open(f"Output/Mode_ex_fiber_frequency{frq:.3f}nm.json", "r") as f:
                        data = json.load(f)
                        
                        # Extract the files
                        Ez1_fiber = np.array(data["Ez"])
                        Hy1_fiber = np.array(data["Hy"])
                        Ez1_fiber_array.append(Ez1_fiber)
                        Hy1_fiber_array.append(Hy1_fiber)
                        fiber_cross_axis = np.array(data['cross_axis'])
                """
# Fixed Simulation settings
sim = mp.Simulation(
cell_size=cell_size,
sources=mode_sources,
geometry=geometry,
resolution=sim_resolution,
boundary_layers=pml_layers)

# Volumes
n_dft = 30          # total monitors
N_active = 5        # max simultaneous monitors
n_dft_active = 0    # Index of the active dft

# Parameters for the simulation
dx = (sim_length - 2*pml_thickness) / n_dft
threshold_value = 0.05
Ez_results = []
Hy_results = []
reference_phase = None
reference_position = None

def stop_when_fields_above(component, point, threshold):
    """Stop when field at ALL points are above threshold"""
    def check(sim):
        v = np.abs(sim.get_field_point(component, point))
        return v > threshold
    return check

for n in range(n_dft + N_active - 1):
        # If we have less than N_active dft window just spawn one
        if len(sim.dft_objects) < N_active and n < n_dft:
                vol = mp.Volume(
                        center=mp.Vector3(pml_thickness + (n + 0.5) * dx - sim_length / 2),
                        size=mp.Vector3(dx, sim_width, 0))
                
                sim.add_dft_fields([mp.Ez, mp.Hy], frq_simulated, where=vol)  

        # Otherwise we can also simulate and extract information
        if n >= n_dft or len(sim.dft_objects) >= N_active:   
                if n_dft_active < n_dft - 2:
                        position_right = mp.Vector3(pml_thickness + (n_dft_active + wvg_neff) * dx - sim_length / 2)
                        sim.run(until=stop_when_fields_above(mp.Ez, position_right, threshold_value))
                else:
                        sim.run(until=wvg_neff*dx)

                n_dft_active += 1

                # Take the first dft and extract electric field
                Ez = sim.get_dft_array(sim.dft_objects[0], mp.Ez, 0)
                Hy = sim.get_dft_array(sim.dft_objects[0], mp.Hy, 0)
                sim.dft_objects.pop(0)

                # Phase alignment using derivative approach
                if len(Ez_results) > 0:  # Not the first monitor
                        prev_Ez = Ez_results[-1]
                        
                        # Calculate expected phase based on previous field's phase gradient
                        center_idx = len(prev_Ez[-1]) // 2
                        prev_phase = np.angle(prev_Ez[-1,center_idx])  # Last few columns
                        curr_phase = np.angle(Ez[0, center_idx])        # First few columns

                        phase_correction = curr_phase - prev_phase
        
                        # Apply correction
                        Ez = Ez * np.exp(-1j * phase_correction)
                        Hy = Hy * np.exp(-1j * phase_correction)
        
                Ez_results.append(Ez[1:])
                Hy_results.append(Hy[1:])

Ez_array = np.vstack(Ez_results)
Hy_array = np.vstack(Hy_results)
plt.figure(figsize=(7, 4))
plt.imshow(
np.abs(Ez_array).T,
aspect='auto',
cmap='RdBu',
interpolation='spline36',
extent=(pml_thickness, sim_length-pml_thickness, 0, sim_width))
plt.xlabel("Propagation direction (x)")
plt.ylabel("Transverse direction (y)")
plt.colorbar(label="|Ez|")
plt.title("Sliding‑window DFT field magnitude")
plt.tight_layout()
plt.show()

field_axis = np.linspace(-sim_width/2, sim_width/2, sim_width * sim_resolution)
# Calculate the overlap at the input
overlap_in = SL.calculate_modal_overlap(
        Ez_cross=Ez1_fiber_array[0],
        Hy_cross=Hy1_fiber_array[0],
        Ez_field=Ez_array,
        Hy_field=Hy_array,
        cross_axis=fiber_cross_axis,
        field_axis=field_axis)